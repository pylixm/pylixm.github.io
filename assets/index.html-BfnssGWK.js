import{_ as a,c as s,a as t,o as e}from"./app-Cpl7-wzY.js";const l="/imgs/complexity/link.jpg",n={};function p(r,i){return e(),s("div",null,[...i[0]||(i[0]=[t(`<blockquote><p>《数据结构与算法-王争》学习笔记，记录备查</p></blockquote><h2 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念"><span>基本概念</span></a></h2><p>链表，通过“指针”将一组凌乱的内存块串联起来使用的数据结构。</p><h2 id="链表的分类" tabindex="-1"><a class="header-anchor" href="#链表的分类"><span>链表的分类</span></a></h2><h3 id="单链表" tabindex="-1"><a class="header-anchor" href="#单链表"><span>单链表</span></a></h3><p><strong>构成</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>-&gt; &lt;data|next&gt; -&gt; &lt;data|next&gt; -&gt; &lt;data|next&gt; -&gt; NULL</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>节点，内存块</li><li>后继指针，记录下个节点地址的指针</li><li>头节点，第一个节点</li><li>尾节点，最后一个节点。最后一个节点的指向是空地址NULL。</li></ul><p><strong>查找</strong></p><p>因为链表的地址空间非连续，无法像数组一样根据下标寻址公式来计算地址，只能从头挨个遍历。查询某值的时间复杂度都是O(n)。</p><p><strong>插入</strong></p><p>插入时，我们只需关注节点的指针指向即可，所以时间复杂度为O(1)。</p><p><strong>删除</strong></p><p>删除时，同插入，移动节点指针即可。时间复杂度为O(1)（此处，并没有算节点的查找所花费的时间，仅为删除操作。如果加上查找，则时间复杂度为O(n)）。</p><h3 id="循环链表" tabindex="-1"><a class="header-anchor" href="#循环链表"><span>循环链表</span></a></h3><p>循环链表，是一种特殊的单链表，即最后一个节点的后继指针保存了头结点的内存地址。大致如下：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">        _______________________________________</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> </span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">       ↓</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">                                      |</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">-</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">&gt; </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">data</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">|</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">next</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">&gt; -</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">data</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">|</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">next</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">&gt; -</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">data</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">|</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">next</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">&gt; </span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">--</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方便查找头节点，其他操作时间复杂度同单链表。</p><h3 id="双向链表" tabindex="-1"><a class="header-anchor" href="#双向链表"><span>双向链表</span></a></h3><p>顾名思义，双向链表，除了后继指针外，还有前驱指针保存前一个节点的内存地址。大致如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>-&gt; &lt;prew|data|next&gt; &lt;-&gt; &lt;prew|data|next&gt; &lt;-&gt; &lt;prew|data|next&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>查找</strong></p><p>因为双向链表支持双向遍历，在需要查找前驱节点的连续操作时，时间复杂度可以降为O(1)。</p><p><strong>插入</strong></p><p>插入时同单链表，只需关注指针指向即可，时间复杂度为O(1)。</p><p><strong>删除</strong></p><p>双向链表和单链表一样，单说删除操作时，仅仅是移动了节点的指针，时间复杂度为O(1)。但是，删除操作时，我们为了操作指针，需要知道删除节点的前一个节点。单链表和双向链表略有不同：</p><ul><li>对于单链表，则需要从头遍历，找到后继指针是我们删除节点地址的节点。时间复杂度为O(n)。</li><li>对于双向链表，则可直接通过前驱指针来获取前驱节点，时间复杂度为O(1)。</li></ul><h3 id="双向循环链表" tabindex="-1"><a class="header-anchor" href="#双向循环链表"><span>双向循环链表</span></a></h3><p>双向循环链表，就是把循环链表和双向链表结合起来的一种数据结构。</p><p>双向链表和单链表相比，多了存储前指针的空间，但是他的操作时间复杂度确大大减少。这便是<strong>空间换时间</strong>的思想，在实际的生产中，我们要根据实际资源情况来合理的使用<strong>空间换时间</strong>或<strong>时间换空间</strong>的思想。</p><h2 id="应用" tabindex="-1"><a class="header-anchor" href="#应用"><span>应用</span></a></h2><h3 id="数组和链表的性能对比" tabindex="-1"><a class="header-anchor" href="#数组和链表的性能对比"><span>数组和链表的性能对比</span></a></h3><p><img src="`+l+'" alt=""></p><ul><li>数组内存空间连续，对CPU的缓存机制友好，CPU可以于都数组的数据，提高访问效率。链表内存不连续，无法连用CPU的缓存机制提高访问效率。</li><li>数组内存固定，扩容耗时严重。链表没有大小限制，可随意动态扩容。</li></ul><h3 id="链表应用" tabindex="-1"><a class="header-anchor" href="#链表应用"><span>链表应用</span></a></h3><ul><li>链表适合插入、删除操作频繁的业务场景</li><li>双向链表比单链表的插入、删除简单、高效。</li><li>循环链表合适要处理的数据具有环形结构特点，如约瑟夫问题。</li></ul><h2 id="常面试点及代码编写技巧" tabindex="-1"><a class="header-anchor" href="#常面试点及代码编写技巧"><span>常面试点及代码编写技巧</span></a></h2><h3 id="考点" tabindex="-1"><a class="header-anchor" href="#考点"><span>考点</span></a></h3><ul><li>单链表的反转</li><li>链表中环的检测。</li><li>连个有序链表合并。</li><li>删除链表倒数第N个节点。</li><li>求链表的中间节点。</li></ul><h3 id="链表编写技巧" tabindex="-1"><a class="header-anchor" href="#链表编写技巧"><span>链表编写技巧</span></a></h3><ul><li><p>理解指针和引用的含义：指针和引用都存储了所致对象的内存地址。<strong>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来指针中存储了存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</strong></p></li><li><p>警惕指针丢失和内存泄露：插入节点时，注意操作的顺序；删除节点时，记着释放内存空间。</p></li><li><p>多用「哨兵节点」简化难度：链表的头节点和尾节点的操作时，哨兵节点可以简化操作。哨兵节点不存储数据。</p><ul><li>带头链表：有哨兵节点的链表</li><li>不带头链表：无哨兵节点的链表</li></ul></li><li><p>留意边界条件处理：几个常见的边界情况</p><ul><li>空链表</li><li>只包含一个结点的链表</li><li>只包含两个结点的链表</li><li>代码逻辑在头结点和尾结点是否正常</li></ul></li><li><p>编写代码时，举例画图可以帮助思考。</p></li></ul><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><ul><li>常见的缓存淘汰策略： <ul><li>FIFO（First In，First Out）</li><li>最少使用策略 LFU（Least Frequently Used）</li><li>最近最少使用策略 LRU（Least Recently Used）</li></ul></li></ul>',44)])])}const d=a(n,[["render",p]]),o=JSON.parse('{"path":"/data-structure-algorithm/2e50ca/","title":"数据结构与算法 - 线性表 - 链表","lang":"zh-CN","frontmatter":{"title":"数据结构与算法 - 线性表 - 链表","tags":["数据结构与算法","链表"],"permalink":"/data-structure-algorithm/2e50ca/","createTime":"2023/09/08 17:36:02","description":"《数据结构与算法-王争》学习笔记，记录备查 基本概念 链表，通过“指针”将一组凌乱的内存块串联起来使用的数据结构。 链表的分类 单链表 构成 节点，内存块 后继指针，记录下个节点地址的指针 头节点，第一个节点 尾节点，最后一个节点。最后一个节点的指向是空地址NULL。 查找 因为链表的地址空间非连续，无法像数组一样根据下标寻址公式来计算地址，只能从头挨...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"数据结构与算法 - 线性表 - 链表\\",\\"image\\":[\\"https://pylixm.top/imgs/complexity/link.jpg\\"],\\"dateModified\\":\\"2025-09-30T08:57:49.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://pylixm.top/data-structure-algorithm/2e50ca/"}],["meta",{"property":"og:site_name","content":"底层逻辑"}],["meta",{"property":"og:title","content":"数据结构与算法 - 线性表 - 链表"}],["meta",{"property":"og:description","content":"《数据结构与算法-王争》学习笔记，记录备查 基本概念 链表，通过“指针”将一组凌乱的内存块串联起来使用的数据结构。 链表的分类 单链表 构成 节点，内存块 后继指针，记录下个节点地址的指针 头节点，第一个节点 尾节点，最后一个节点。最后一个节点的指向是空地址NULL。 查找 因为链表的地址空间非连续，无法像数组一样根据下标寻址公式来计算地址，只能从头挨..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://pylixm.top/imgs/complexity/link.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-30T08:57:49.000Z"}],["meta",{"property":"article:tag","content":"链表"}],["meta",{"property":"article:tag","content":"数据结构与算法"}],["meta",{"property":"article:modified_time","content":"2025-09-30T08:57:49.000Z"}]]},"readingTime":{"minutes":4.27,"words":1282},"git":{"createdTime":1759222669000,"updatedTime":1759222669000,"contributors":[{"name":"pylixm","username":"pylixm","email":"pyli.xm@gmail.com","commits":1,"avatar":"https://avatars.githubusercontent.com/pylixm?v=4","url":"https://github.com/pylixm"}]},"autoDesc":true,"filePathRelative":"notes/04.数据结构与算法笔记/03.DSALG-link.md","headers":[]}');export{d as comp,o as data};
