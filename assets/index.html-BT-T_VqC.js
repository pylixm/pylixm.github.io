import{_ as i,c as a,a as e,o as n}from"./app-Cpl7-wzY.js";const l="/imgs/docker-on-linux.png",p="/imgs/docker-execdriver-diagram.png",r="/imgs/docker-networking.jpg",d="/imgs/docker-vethbridge.png",t={};function c(h,s){return n(),a("div",null,[...s[0]||(s[0]=[e('<blockquote><p>原文地址：https://blog.opskumu.com/docker.html 本文对原文进行了更新和补充，转载备查。</p></blockquote><h2 id="一、docker-简介" tabindex="-1"><a class="header-anchor" href="#一、docker-简介"><span>一、Docker 简介</span></a></h2><p>Docker 是一种轻量级的虚拟化技术，是一种Linux容器（Linux Containers，缩写为 LXC）技术的封装。</p><p>大多数人可能知道虚拟机，可以在一台硬件机器上虚拟出另一台计算机，有它自己的cpu、硬盘等各种虚拟的硬件。而 Linux 容器技术也是一种虚拟技术，但是它并非直接从硬件上来虚拟，而是通过软件技术对进程及资源进行隔离，从而达到虚拟化的目的。Docker 就是一种这样隔离虚拟化技术。</p><p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 containerd。</p><p><img src="'+l+'" alt="docker_arch"></p><p>Docker 发展之迅速，除了分布式和微服务的大潮外，还得益于其优秀的特性。</p><p><strong>更高效的利用系统资源</strong></p><p>Docker 容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。</p><p><strong>更快速的启动时间</strong></p><p>Docker 直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><p><strong>一致的运行环境</strong></p><p>Docker 容器中有镜像的概念，Docker 容器有镜像生成，镜像保证了除内核外的运行环境。</p><p><strong>持续交付和部署</strong></p><p>也是因为镜像技术，可以使Devops人员实现持续集成、持续交付、部署，一次构建可在任意地方运行。</p><p><strong>更轻松的迁移</strong></p><p>Docker 容器封装了软件运行环境，使其不依赖系统，使其更容易移植。</p><p><strong>更轻松的维护和扩展</strong></p><p>Docker 使用分层存储和镜像技术，使得镜像可重复使用，维护和扩展更轻松。</p><p><strong>Docker相较虚拟机优势明显</strong></p><p>Docker 两个主要部件：</p><ul><li>Docker: 开源的容器虚拟化平台</li><li>Docker Hub: 用于分享、管理 Docker 容器镜像的 Docker SaaS 平台 – Docker Hub</li></ul><p>Docker 使用客户端-服务器 (C/S) 架构模式。Docker 客户端会与 Docker 守护进程进行通信。Docker 守护进程会处理复杂繁重的任务，例如建立、运行、发布你的 Docker 容器。Docker 客户端和守护进程可以运行在同一个系统上，当然你也可以使用 Docker 客户端去连接一个远程的 Docker 守护进程。Docker 客户端和守护进程之间通过 socket 或者 RESTful API 进行通信。</p><h3 id="_1-1-docker-守护进程" tabindex="-1"><a class="header-anchor" href="#_1-1-docker-守护进程"><span>1.1 Docker 守护进程</span></a></h3><p>如上图所示，Docker 守护进程运行在一台主机上。用户并不直接和守护进程进行交互，而是通过 Docker 客户端间接和其通信。</p><h3 id="_1-2-docker-客户端" tabindex="-1"><a class="header-anchor" href="#_1-2-docker-客户端"><span>1.2 Docker 客户端</span></a></h3><p>Docker 客户端，实际上是 docker 的二进制程序，是主要的用户与 Docker 交互方式。它接收用户指令并且与背后的 Docker 守护进程通信，如此来回往复。</p><h3 id="_1-3-docker-内部" tabindex="-1"><a class="header-anchor" href="#_1-3-docker-内部"><span>1.3 Docker 内部</span></a></h3><p>要理解 Docker 内部构建，需要理解以下三种部件：</p><ul><li>Docker 镜像 - Docker images</li><li>Docker 仓库 - Docker registeries</li><li>Docker 容器 - Docker containers</li></ul><h4 id="docker-镜像" tabindex="-1"><a class="header-anchor" href="#docker-镜像"><span>Docker 镜像</span></a></h4><p>Docker 镜像是 Docker 容器运行时的只读模板，每一个镜像由一系列的层 (layers) 组成。Docker 使用 UnionFS（一种Linux 下的文件系统，Linux 内核4.x以后不再支持，Docker公司开发了自己的文件系统如OverlayFS和overlay2。） 来将这些层联合到单独的镜像中。UnionFS 允许独立文件系统中的文件和文件夹(称之为分支)被透明覆盖，形成一个单独连贯的文件系统。正因为有了这些层的存在，Docker 是如此的轻量。当你改变了一个 Docker 镜像，比如升级到某个程序到新的版本，一个新的层会被创建。因此，不用替换整个原先的镜像或者重新建立(在使用虚拟机的时候你可能会这么做)，只是一个新的层被添加或升级了。现在你不用重新发布整个镜像，只需要“升级”，层使得分发 Docker 镜像变得简单和快速。</p><p>Docker有各种存储驱动程序（https://docs.docker.com/engine/userguide/storagedriver/selectadriver/）。唯一得到广泛支持的驱动程序就是AUFS。</p><p>镜像具有以下特点：</p><ul><li>类似虚拟机的快照，但更轻量，非常非常轻量。</li><li>镜像拥有唯一ID，以及一个供人阅读的名字和标签对。</li><li>只读层被称为镜像，一个镜像是永久不会变的。</li><li>由于 Docker 使用一个统一文件系统，Docker 进程认为整个文件系统是以读写方式挂载的。 但是所有的变更都发生顶层的可写层，而下层的原始的只读镜像文件并未变化。由于镜像不可写，所以镜像是无状态的。</li></ul><h4 id="docker-仓库" tabindex="-1"><a class="header-anchor" href="#docker-仓库"><span>Docker 仓库</span></a></h4><p>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。同样的，Docker 仓库也有公有和私有的概念。公有的 Docker 仓库名字是 Docker Hub。Docker Hub 提供了庞大的镜像集合供使用。这些镜像可以是自己创建，或者在别人的镜像基础上创建。Docker 仓库是 Docker 的分发部分。</p><h4 id="docker-容器" tabindex="-1"><a class="header-anchor" href="#docker-容器"><span>Docker 容器</span></a></h4><p>Docker 容器和文件夹很类似，一个Docker容器包含了所有的某个应用运行所需要的环境。每一个 Docker 容器都是从 Docker 镜像创建的。Docker 容器可以运行、开始、停止、移动和删除。每一个 Docker 容器都是独立和安全的应用平台，Docker 容器是 Docker 的运行部分。</p><h3 id="_1-4-libcontainer" tabindex="-1"><a class="header-anchor" href="#_1-4-libcontainer"><span>1.4 libcontainer</span></a></h3><p>Docker 从 0.9 版本开始使用 libcontainer 替代 lxc，libcontainer 和 Linux 系统的交互图如下：</p><p><img src="'+p+`" alt=""></p><p>图片来源: <a href="https://www.docker.com/blog/docker-0-9-introducing-execution-drivers-and-libcontainer/" target="_blank" rel="noopener noreferrer">Docker 0.9: introducing execution drivers and libcontainer</a></p><h3 id="_1-5-命名空间「namespaces」" tabindex="-1"><a class="header-anchor" href="#_1-5-命名空间「namespaces」"><span>1.5 命名空间「Namespaces」</span></a></h3><h4 id="pid-namespace" tabindex="-1"><a class="header-anchor" href="#pid-namespace"><span>pid namespace</span></a></h4><p>不同用户的进程就是通过 pid namespace 隔离开的，且不同 namespace 中可以有相同 PID。具有以下特征:</p><ul><li>每个 namespace 中的 pid 是有自己的 pid=1 的进程(类似 /sbin/init 进程)</li><li>每个 namespace 中的进程只能影响自己的同一个 namespace 或子 namespace 中的进程</li><li>因为 /proc 包含正在运行的进程，因此在 container 中的 pseudo-filesystem 的 /proc 目录只能看到自己 namespace 中的进程</li><li>因为 namespace 允许嵌套，父 namespace 可以影响子 namespace 的进程，所以子 namespace 的进程可以在父 namespace 中看到，但是具有不同的 pid</li></ul><p>参考文档：<a href="https://blog.jtlebi.fr/2014/01/05/introduction-to-linux-namespaces-part-3-pid/" target="_blank" rel="noopener noreferrer">Introduction to Linux namespaces – Part 3: PID</a></p><h4 id="mnt-namespace" tabindex="-1"><a class="header-anchor" href="#mnt-namespace"><span>mnt namespace</span></a></h4><p>类似 chroot，将一个进程放到一个特定的目录执行。mnt namespace 允许不同 namespace 的进程看到的文件结构不同，这样每个 namespace 中的进程所看到的文件目录就被隔离开了。同 chroot 不同，每个 namespace 中的 container 在 /proc/mounts 的信息只包含所在 namespace 的 mount point。</p><h4 id="net-namespace" tabindex="-1"><a class="header-anchor" href="#net-namespace"><span>net namespace</span></a></h4><p>网络隔离是通过 net namespace 实现的， 每个 net namespace 有独立的 network devices, IP addresses, IP routing tables, /proc/net 目录。这样每个 container 的网络就能隔离开来。 docker 默认采用 veth 的方式将 container 中的虚拟网卡同 host 上的一个 docker bridge 连接在一起。</p><p>参考文档：<a href="https://blog.jtlebi.fr/2014/01/19/introduction-to-linux-namespaces-part-5-net/" target="_blank" rel="noopener noreferrer">Introduction to Linux namespaces – Part 5: NET</a></p><h4 id="uts-namespace" tabindex="-1"><a class="header-anchor" href="#uts-namespace"><span>uts namespace</span></a></h4><p>UTS (“UNIX Time-sharing System”) namespace 允许每个 container 拥有独立的 hostname 和 domain name, 使其在网络上可以被视作一个独立的节点而非 Host 上的一个进程。</p><p>参考文档：<a href="https://blog.jtlebi.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/" target="_blank" rel="noopener noreferrer">Introduction to Linux namespaces – Part 1: UTS</a></p><h4 id="ipc-namespace" tabindex="-1"><a class="header-anchor" href="#ipc-namespace"><span>ipc namespace</span></a></h4><p>container 中进程交互还是采用 Linux 常见的进程间交互方法 (interprocess communication - IPC), 包括常见的信号量、消息队列和共享内存。然而同 VM 不同，container 的进程间交互实际上还是 host 上具有相同 pid namespace 中的进程间交互，因此需要在IPC资源申请时加入 namespace 信息 - 每个 IPC 资源有一个唯一的 32bit ID。</p><p>参考文档：<a href="https://blog.jtlebi.fr/2013/12/28/introduction-to-linux-namespaces-part-2-ipc/" target="_blank" rel="noopener noreferrer">Introduction to Linux namespaces – Part 2: IPC</a></p><h4 id="user-namespace" tabindex="-1"><a class="header-anchor" href="#user-namespace"><span>user namespace</span></a></h4><p>每个 container 可以有不同的 user 和 group id, 也就是说可以以 container 内部的用户在 container 内部执行程序而非 Host 上的用户。</p><p>有了以上 6 种 namespace 从进程、网络、IPC、文件系统、UTS 和用户角度的隔离，一个 container 就可以对外展现出一个独立计算机的能力，并且不同 container 从 OS 层面实现了隔离。 然而不同 namespace 之间资源还是相互竞争的，仍然需要类似 ulimit 来管理每个 container 所能使用的资源 - cgroup。</p><p>####Reference</p><ul><li><a href="http://tiewei.github.io/cloud/Docker-Getting-Start/" target="_blank" rel="noopener noreferrer">Docker Getting Start: Related Knowledge</a></li><li><a href="https://ruby-china.org/topics/22004" target="_blank" rel="noopener noreferrer">Docker 介绍以及其相关术语、底层原理和技术</a></li></ul><h3 id="_1-6-资源配额「cgroups」" tabindex="-1"><a class="header-anchor" href="#_1-6-资源配额「cgroups」"><span>1.6 资源配额「cgroups」</span></a></h3><p>cgroups 实现了对资源的配额和度量。 cgroups 的使用非常简单，提供类似文件的接口，在 /cgroup 目录下新建一个文件夹即可新建一个 group，在此文件夹中新建 task 文件，并将 pid 写入该文件，即可实现对该进程的资源控制。具体的资源配置选项可以在该文件夹中新建子 subsystem ，&lt;子系统前缀&gt;.&lt;资源项&gt; 是典型的配置方法， 如 memory.usage_in_bytes 就定义了该 group 在 subsystem memory 中的一个内存限制选项。 另外，cgroups 中的 subsystem 可以随意组合，一个 subsystem 可以在不同的 group 中，也可以一个 group 包含多个 subsystem - 也就是说一个 subsystem。</p><ul><li>memory <ul><li>内存相关的限制</li></ul></li><li>cpu <ul><li>在 cgroup 中，并不能像硬件虚拟化方案一样能够定义 CPU 能力，但是能够定义 CPU 轮转的优先级，因此具有较高 CPU 优先级的进程会更可能得到 CPU 运算。 通过将参数写入 cpu.shares ,即可定义改 cgroup 的 CPU 优先级 - 这里是一个相对权重，而非绝对值</li></ul></li><li>blkio <ul><li>block IO 相关的统计和限制，byte/operation 统计和限制 (IOPS 等)，读写速度限制等，但是这里主要统计的都是同步 IO</li></ul></li><li>devices <ul><li>设备权限限制</li></ul></li></ul><p>参考文档：<a href="http://tiewei.github.io/devops/howto-use-cgroup/" target="_blank" rel="noopener noreferrer">how to use cgroup</a></p><h2 id="二、docker-安装" tabindex="-1"><a class="header-anchor" href="#二、docker-安装"><span>二、Docker 安装</span></a></h2><p>docker 的相关安装方法这里不作介绍，具体安装参考 <a href="https://docs.docker.com/installation/" target="_blank" rel="noopener noreferrer">官档</a></p><p>获取当前 docker 版本</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> docker</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> version</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Client:</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Version:</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">      18.03.1-ce</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> API</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> version:</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">  1.37</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Go</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> version:</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">   go1.9.5</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Git</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> commit:</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">   9ee9f40</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Built:</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">        Thu</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> Apr</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 26</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 07:13:02</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 2018</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> OS/Arch:</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">      darwin/amd64</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Experimental:</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> false</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Orchestrator:</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> swarm</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Server:</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Engine:</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  Version:</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">      18.03.1-ce</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  API</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> version:</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">  1.37</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> (minimum </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">version</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1.12</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">)</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  Go</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> version:</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">   go1.9.5</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  Git</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> commit:</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">   9ee9f40</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  Built:</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">        Thu</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> Apr</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 26</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 07:22:38</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 2018</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  OS/Arch:</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">      linux/amd64</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  Experimental:</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> false</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="三、docker-基础用法" tabindex="-1"><a class="header-anchor" href="#三、docker-基础用法"><span>三、Docker 基础用法</span></a></h2><p><a href="https://registry.hub.docker.com/" target="_blank" rel="noopener noreferrer">Docker HUB</a> : Docker镜像首页，包括官方镜像和其它公开镜像</p><p>因为国情的原因，国内下载 Docker HUB 官方的相关镜像比较慢，可以使用 <a href="http://daocloud.com/" target="_blank" rel="noopener noreferrer">Daocloud</a> 镜像加速。</p><h3 id="_3-1-search-images" tabindex="-1"><a class="header-anchor" href="#_3-1-search-images"><span>3.1 Search images</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker search ubuntu</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_3-2-pull-images" tabindex="-1"><a class="header-anchor" href="#_3-2-pull-images"><span>3.2 Pull images</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker pull ubuntu # 获取 ubuntu 官方镜像</span></span>
<span class="line"><span>$ sudo docker images # 查看当前镜像列表</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-3-running-an-interactive-shell" tabindex="-1"><a class="header-anchor" href="#_3-3-running-an-interactive-shell"><span>3.3 Running an interactive shell</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker run -i -t ubuntu:14.04 /bin/bash</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>docker run - 运行一个容器</li><li>-t - 分配一个（伪）tty (link is external)</li><li>-i - 交互模式 (so we can interact with it)</li><li>ubuntu:14.04 - 使用 ubuntu 基础镜像 14.04</li><li>/bin/bash - 运行命令 bash shell</li></ul><p>注: ubuntu 会有多个版本，通过指定 tag 来启动特定的版本 [image]:[tag]</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker ps # 查看当前运行的容器, ps -a 列出当前系统所有的容器</span></span>
<span class="line"><span>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span></span>
<span class="line"><span>6c9129e9df10        ubuntu:14.04        /bin/bash           6 minutes ago       Up 6 minutes                            cranky_babbage</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-4-相关快捷键" tabindex="-1"><a class="header-anchor" href="#_3-4-相关快捷键"><span>3.4 相关快捷键</span></a></h3><ul><li>退出：Ctrl-D or exit</li><li>detach：Ctrl-P + Ctrl-Q</li><li>attach: docker attach CONTAINER-ID</li></ul><h2 id="四、docker-常用命令" tabindex="-1"><a class="header-anchor" href="#四、docker-常用命令"><span>四、Docker 常用命令</span></a></h2><h3 id="_4-1-docker-help" tabindex="-1"><a class="header-anchor" href="#_4-1-docker-help"><span>4.1 docker help</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker   # docker 命令帮助</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_4-2-docker-search" tabindex="-1"><a class="header-anchor" href="#_4-2-docker-search"><span>4.2 docker search</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker search --help</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span># 查找 star 数至少为 100 的镜像，找出只有官方镜像 start 数超过 100，默认不加 s 选项找出所有相关 ubuntu 镜像</span></span>
<span class="line"><span>$ docker search -s 100 ubuntu</span></span>
<span class="line"><span>Flag --stars has been deprecated, use --filter=stars=3 instead</span></span>
<span class="line"><span>NAME                             DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span></span>
<span class="line"><span>ubuntu                           Ubuntu is a Debian-based Linux operating sys…   7755                [OK]</span></span>
<span class="line"><span>dorowu/ubuntu-desktop-lxde-vnc   Ubuntu with openssh-server and NoVNC            185                                     [OK]</span></span>
<span class="line"><span>rastasheep/ubuntu-sshd           Dockerized SSH service, built on top of offi…   151                                     [OK]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-3-docker-info" tabindex="-1"><a class="header-anchor" href="#_4-3-docker-info"><span>4.3 docker info</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker info</span></span>
<span class="line"><span>Containers: 0   # 容器个数</span></span>
<span class="line"><span> Running: 0</span></span>
<span class="line"><span> Paused: 0</span></span>
<span class="line"><span> Stopped: 0</span></span>
<span class="line"><span>Images: 20   # 镜像个数</span></span>
<span class="line"><span>Server Version: 18.05.0-ce</span></span>
<span class="line"><span>Storage Driver: overlay2   # 存储驱动</span></span>
<span class="line"><span> Backing Filesystem: extfs</span></span>
<span class="line"><span> Supports d_type: true</span></span>
<span class="line"><span> Native Overlay Diff: true</span></span>
<span class="line"><span>Logging Driver: json-file</span></span>
<span class="line"><span>Cgroup Driver: cgroupfs</span></span>
<span class="line"><span>Plugins:</span></span>
<span class="line"><span> Volume: local</span></span>
<span class="line"><span> Network: bridge host macvlan null overlay</span></span>
<span class="line"><span> Log: awslogs fluentd gcplogs gelf journald json-file logentries splunk syslog</span></span>
<span class="line"><span>Swarm: inactive</span></span>
<span class="line"><span>Runtimes: runc</span></span>
<span class="line"><span>Default Runtime: runc</span></span>
<span class="line"><span>Init Binary: docker-init</span></span>
<span class="line"><span>containerd version: 773c489c9c1b21a6d78b5c538cd395416ec50f88</span></span>
<span class="line"><span>runc version: 4fc53a81fb7c994640722ac585fa9ca548971871</span></span>
<span class="line"><span>init version: 949e6fa</span></span>
<span class="line"><span>Security Options:</span></span>
<span class="line"><span> seccomp</span></span>
<span class="line"><span>  Profile: default</span></span>
<span class="line"><span>Kernel Version: 3.10.0-693.5.2.el7.x86_64   # 主机内核</span></span>
<span class="line"><span>Operating System: CentOS Linux 7 (Core)</span></span>
<span class="line"><span>OSType: linux</span></span>
<span class="line"><span>Architecture: x86_64</span></span>
<span class="line"><span>CPUs: 1</span></span>
<span class="line"><span>Total Memory: 992.4MiB</span></span>
<span class="line"><span>Name: xxxxx</span></span>
<span class="line"><span>ID: xxxxxx</span></span>
<span class="line"><span>Docker Root Dir: /var/lib/docker</span></span>
<span class="line"><span>Debug Mode (client): false</span></span>
<span class="line"><span>Debug Mode (server): false</span></span>
<span class="line"><span>Registry: https://index.docker.io/v1/</span></span>
<span class="line"><span>Labels:</span></span>
<span class="line"><span>Experimental: false</span></span>
<span class="line"><span>Insecure Registries:</span></span>
<span class="line"><span> 127.0.0.0/8</span></span>
<span class="line"><span>Live Restore Enabled: false</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-4-docker-pull-docker-push" tabindex="-1"><a class="header-anchor" href="#_4-4-docker-pull-docker-push"><span>4.4 docker pull &amp;&amp; docker push</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker pull &lt;images-name&gt;:&lt;tag&gt;  # pull 拉取镜像</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker pull ubuntu           # 下载官方 ubuntu docker 镜像，默认下载所有 ubuntu 官方库镜像</span></span>
<span class="line"><span>$ sudo docker pull ubuntu:14.04     # 下载指定版本 ubuntu 官方镜像</span></span>
<span class="line"><span>$ sudo docker push 192.168.0.100:5000/ubuntu # 推送镜像库到私有源[可注册 docker 官方账户，推送到官方自有账户]</span></span>
<span class="line"><span>$ sudo docker push 192.168.0.100:5000/ubuntu:14.04 # 推送指定镜像到私有源</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-5-docker-images" tabindex="-1"><a class="header-anchor" href="#_4-5-docker-images"><span>4.5 docker images</span></a></h3><p>列出当前系统镜像</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker images &lt;images-name&gt;:&lt;tag&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker images            # 显示当前系统镜像，不包括过渡层镜像</span></span>
<span class="line"><span>$ sudo docker images -a         # 显示当前系统所有镜像，包括过渡层镜像</span></span>
<span class="line"><span>$ sudo docker images ubuntu     # 显示当前系统 docker ubuntu 库中的所有镜像</span></span>
<span class="line"><span>REPOSITORY                 TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span></span>
<span class="line"><span>ubuntu                     12.04               ebe4be4dd427        4 weeks ago         210.6 MB</span></span>
<span class="line"><span>ubuntu                     14.04               e54ca5efa2e9        4 weeks ago         276.5 MB</span></span>
<span class="line"><span>ubuntu                     14.04-ssh           6334d3ac099a        7 weeks ago         383.2 MB</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-6-docker-rmi" tabindex="-1"><a class="header-anchor" href="#_4-6-docker-rmi"><span>4.6 docker rmi</span></a></h3><p>删除一个或者多个镜像</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker rmi --help</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Usage: docker rmi IMAGE [IMAGE...]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Remove one or more images</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  -f, --force=false    Force removal of the image       # 强制移除镜像不管是否有容器使用该镜像</span></span>
<span class="line"><span>  --no-prune=false     Do not delete untagged parents   # 不要删除未标记的父镜像</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-7-docker-run" tabindex="-1"><a class="header-anchor" href="#_4-7-docker-run"><span>4.7 docker run</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker images ubuntu</span></span>
<span class="line"><span>REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span></span>
<span class="line"><span>ubuntu              14.04               e54ca5efa2e9        4 weeks ago         276.5 MB</span></span>
<span class="line"><span>... ...</span></span>
<span class="line"><span>$ sudo docker run -t -i -c 100 -m 512MB -h test1 -d --name=&quot;docker_test1&quot; ubuntu /bin/bash</span></span>
<span class="line"><span># 创建一个 cpu 优先级为 100，内存限制 512MB，主机名为 test1，名为 docker_test1 后台运行 bash 的容器</span></span>
<span class="line"><span>a424ca613c9f2247cd3ede95adfbaf8d28400cbcb1d5f9b69a7b56f97b2b52e5</span></span>
<span class="line"><span>$ sudo docker ps</span></span>
<span class="line"><span>CONTAINER ID        IMAGE           COMMAND         CREATED             STATUS              PORTS       NAMES</span></span>
<span class="line"><span>a424ca613c9f        ubuntu:14.04    /bin/bash       6 seconds ago       Up 5 seconds                    docker_test1</span></span>
<span class="line"><span>$ sudo docker attach docker_test1</span></span>
<span class="line"><span>root@test1:/# pwd</span></span>
<span class="line"><span>/</span></span>
<span class="line"><span>root@test1:/# exit</span></span>
<span class="line"><span>exit</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于cpu优先级:</p><blockquote><p>By default all groups have 1024 shares. A group with 100 shares will get a ~10% portion of the CPU time -archlinux cgroups</p></blockquote><h3 id="_4-8-其他-docker" tabindex="-1"><a class="header-anchor" href="#_4-8-其他-docker"><span>4.8 其他 docker</span></a></h3><ul><li>docker create -t -i fedora bash <ul><li>创建容器，但不启动</li></ul></li><li>docker start CONTAINER [CONTAINER…] <ul><li>运行一个或多个停止的容器</li></ul></li><li>docker stop CONTAINER [CONTAINER…] <ul><li>停掉一个或多个运行的容器 -t 选项可指定超时时间</li></ul></li><li>docker kill [OPTIONS] CONTAINER [CONTAINER…] <ul><li>默认 kill 发送 SIGKILL 信号 -s 可以指定发送 kill 信号类型</li></ul></li><li>docker restart [OPTIONS] CONTAINER [CONTAINER…] <ul><li>重启一个或多个运行的容器 -t 选项可指定超时时间</li></ul></li><li>docker pause CONTAINER <ul><li>暂停一个容器，方便 commit</li></ul></li><li>docker unpause CONTAINER <ul><li>继续暂停的容器</li></ul></li><li>docker rm [OPTIONS] CONTAINER [CONTAINER…] <ul><li>移除一个或多个容器</li><li>-f, –force=false Force removal of running container</li><li>-l, –link=false Remove the specified link and not the underlying container</li><li>-v, –volumes=false Remove the volumes associated with the container</li></ul></li><li>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] <ul><li>提交指定容器为镜像</li><li>-a, –author=”” Author (e.g., “John Hannibal Smith hannibal@a-team.com”)</li><li>-m, –message=”” Commit message</li><li>-p, –pause=true Pause container during commit</li><li>默认 commit 是暂停状态</li></ul></li><li>docker inspect CONTAINER|IMAGE [CONTAINER|IMAGE…] <ul><li>查看容器或者镜像的详细信息</li></ul></li><li>docker logs CONTAINER <ul><li>输出指定容器日志信息</li><li>-f, –follow=false Follow log output</li><li>类似 tail -f</li><li>-t, –timestamps=false Show timestamps</li><li>–tail=”all” Output the specified number of lines at the end of logs (defaults to all logs)</li></ul></li><li>docker exec -it ubuntu_bash bash <ul><li>进入容器 docker 1.3 后新增</li></ul></li><li>docker attach <ul><li>进入容器， exit 退出后，容器会关闭</li></ul></li></ul><p>参考文档：<a href="https://docs.docker.com/reference/run/" target="_blank" rel="noopener noreferrer">Docker Run Reference</a></p><h2 id="五、docker-端口映射" tabindex="-1"><a class="header-anchor" href="#五、docker-端口映射"><span>五、Docker 端口映射</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span># Find IP address of container with ID &lt;container_id&gt; 通过容器 id 获取 ip</span></span>
<span class="line"><span>$ sudo docker inspect &lt;container_id&gt; | grep IPAddress | cut -d ’&quot;’ -f 4</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>无论如何，这些 ip 是基于本地系统的并且容器的端口非本地主机是访问不到的。此外，除了端口只能本地访问外，对于容器的另外一个问题是这些 ip 在容器每次启动的时候都会改变。</p><p>Docker 解决了容器的这两个问题，并且给容器内部服务的访问提供了一个简单而可靠的方法。Docker 通过端口绑定主机系统的接口，允许非本地客户端访问容器内部运行的服务。为了简便的使得容器间通信，Docker 提供了这种连接机制。</p><h3 id="_5-1-自动映射端口" tabindex="-1"><a class="header-anchor" href="#_5-1-自动映射端口"><span>5.1 自动映射端口</span></a></h3><p>-P 使用时需要指定 --expose 选项，指定需要对外提供服务的端口</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker run -t -P --expose 22 --name server  ubuntu:14.04</span></span>
<span class="line"><span># 使用 docker run -P 自动绑定所有对外提供服务的容器端口，映射的端口将会从没有使用的端口池中 (49000..49900) 自动选择，你可以通过docker ps 、docker inspect &lt;container_id&gt; 或者 docker port &lt;container_id&gt; &lt;port&gt; 确定具体的绑定信息。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-2-绑定端口到指定接口" tabindex="-1"><a class="header-anchor" href="#_5-2-绑定端口到指定接口"><span>5.2 绑定端口到指定接口</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker run -p [([&lt;host_interface&gt;:[host_port]])|(&lt;host_port&gt;):]&lt;container_port&gt;[/udp] &lt;image&gt; &lt;cmd&gt;</span></span>
<span class="line"><span># 默认不指定绑定 ip 则监听所有网络接口。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>示例：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 绑定 TCP 端口</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># Bind TCP port 8080 of the container to TCP port 80 on 127.0.0.1 of the host machine.</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> sudo</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> docker</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> run</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -p</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 127.0.0.1:80:8080</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">imag</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">e</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">cm</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">d</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># Bind TCP port 8080 of the container to a dynamically allocated TCP port on 127.0.0.1 of the host machine.</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> sudo</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> docker</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> run</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -p</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 127.0.0.1::8080</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">imag</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">e</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">cm</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">d</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># Bind TCP port 8080 of the container to TCP port 80 on all available interfaces of the host machine.</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> sudo</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> docker</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> run</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -p</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 80:8080</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">imag</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">e</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">cm</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">d</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># Bind TCP port 8080 of the container to a dynamically allocated TCP port on all available interfaces</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> sudo</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> docker</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> run</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -p</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 8080</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">imag</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">e</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">cm</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">d</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 绑定 UDP 端口</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># Bind UDP port 5353 of the container to UDP port 53 on 127.0.0.1 of the host machine.</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> sudo</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> docker</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> run</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -p</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 127.0.0.1:53:5353/udp</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">imag</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">e</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">cm</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">d</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="六、docker-网络配置" tabindex="-1"><a class="header-anchor" href="#六、docker-网络配置"><span>六、Docker 网络配置</span></a></h2><p><img src="`+r+'" alt=""></p><p>图: <a href="http://www.slideshare.net/janghoonsim/docker-container-and-lightweight-virtualization" target="_blank" rel="noopener noreferrer">Docker - container and lightweight virtualization</a></p><p>Dokcer 通过使用 Linux 桥接提供容器之间的通信，docker0 桥接接口的目的就是方便 Docker 管理。当 Docker daemon 启动时需要做以下操作：</p><ul><li>creates the docker0 bridge if not present # 如果 docker0 不存在则创建</li><li>searches for an IP address range which doesn’t overlap with an existing route # 搜索一个与当前路由不冲突的 ip 段</li><li>picks an IP in the selected range # 在确定的范围中选择 ip</li><li>assigns this IP to the docker0 bridge # 绑定 ip 到 docker0</li></ul><h3 id="_6-1-docker-四种网络模式" tabindex="-1"><a class="header-anchor" href="#_6-1-docker-四种网络模式"><span>6.1 Docker 四种网络模式</span></a></h3><p>四种网络模式摘自 <a href="http://www.infoq.com/cn/articles/docker-network-and-pipework-open-source-explanation-practice" target="_blank" rel="noopener noreferrer">Docker 网络详解及 pipework 源码解读与实践</a></p><p>docker run 创建 Docker 容器时，可以用 –net 选项指定容器的网络模式，Docker 有以下 4 种网络模式：</p><ul><li>host 模式，使用 –net=host 指定。</li><li>container 模式，使用 –net=container:NAME_or_ID 指定。</li><li>none 模式，使用 –net=none 指定。</li><li>bridge 模式，使用 –net=bridge 指定，默认设置。</li></ul><h4 id="host-模式" tabindex="-1"><a class="header-anchor" href="#host-模式"><span>host 模式</span></a></h4><p>如果启动容器的时候使用 host 模式，那么这个容器将不会获得一个独立的 Network Namespace，而是和宿主机共用一个 Network Namespace。容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。</p><p>例如，我们在 10.10.101.105/24 的机器上用 host 模式启动一个含有 web 应用的 Docker 容器，监听 tcp 80 端口。当我们在容器中执行任何类似 ifconfig 命令查看网络环境时，看到的都是宿主机上的信息。而外界访问容器中的应用，则直接使用 10.10.101.105:80 即可，不用任何 NAT 转换，就如直接跑在宿主机中一样。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p><h4 id="container-模式" tabindex="-1"><a class="header-anchor" href="#container-模式"><span>container 模式</span></a></h4><p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p><h4 id="none模式" tabindex="-1"><a class="header-anchor" href="#none模式"><span>none模式</span></a></h4><p>这个模式和前两个不同。在这种模式下，Docker 容器拥有自己的 Network Namespace，但是，并不为 Docker容器进行任何网络配置。也就是说，这个 Docker 容器没有网卡、IP、路由等信息。需要我们自己为 Docker 容器添加网卡、配置 IP 等。</p><h4 id="bridge模式" tabindex="-1"><a class="header-anchor" href="#bridge模式"><span>bridge模式</span></a></h4><p><img src="'+d+`" alt=""></p><p>图:<a href="http://www.wickedawesometech.us/2014/07/the-container-world-part-2-networking.html" target="_blank" rel="noopener noreferrer">The Container World Part 2 Networking</a></p><p>bridge 模式是 Docker 默认的网络设置，此模式会为每一个容器分配 Network Namespace、设置 IP 等，并将一个主机上的 Docker 容器连接到一个虚拟网桥上。当 Docker server 启动时，会在主机上创建一个名为 docker0 的虚拟网桥，此主机上启动的 Docker 容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。接下来就要为容器分配 IP 了，Docker 会从 RFC1918 所定义的私有 IP 网段中，选择一个和宿主机不同的IP地址和子网分配给 docker0，连接到 docker0 的容器就从这个子网中选择一个未占用的 IP 使用。如一般 Docker 会使用 172.17.0.0/16 这个网段，并将 172.17.42.1/16 分配给 docker0 网桥（在主机上使用 ifconfig 命令是可以看到 docker0 的，可以认为它是网桥的管理接口，在宿主机上作为一块虚拟网卡使用）</p><h3 id="_6-2-列出当前主机网桥" tabindex="-1"><a class="header-anchor" href="#_6-2-列出当前主机网桥"><span>6.2 列出当前主机网桥</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> sudo</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> brctl</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> show</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  # brctl 工具依赖 bridge-utils 软件包</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">bridge</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> name</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> bridge</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> id</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> STP</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> enabled</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> interfaces</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">docker0</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 8000.000000000000</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> no</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-3-查看当前-docker0-ip" tabindex="-1"><a class="header-anchor" href="#_6-3-查看当前-docker0-ip"><span>6.3 查看当前 docker0 ip</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo ifconfig docker0</span></span>
<span class="line"><span>docker0 Link encap:Ethernet HWaddr xx:xx:xx:xx:xx:xx</span></span>
<span class="line"><span>inet addr:172.17.42.1 Bcast:0.0.0.0 Mask:255.255.0.0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在容器运行时，每个容器都会分配一个特定的虚拟机口并桥接到 docker0。每个容器都会配置同 docker0 ip 相同网段的专用 ip 地址，docker0 的 IP 地址被用于所有容器的默认网关。</p><h3 id="_6-4-运行一个容器" tabindex="-1"><a class="header-anchor" href="#_6-4-运行一个容器"><span>6.4 运行一个容器</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker run -t -i -d ubuntu /bin/bash</span></span>
<span class="line"><span>52f811c5d3d69edddefc75aff5a4525fc8ba8bcfa1818132f9dc7d4f7c7e78b4</span></span>
<span class="line"><span>$ sudo brctl show</span></span>
<span class="line"><span>bridge name bridge id STP enabled interfaces</span></span>
<span class="line"><span>docker0 8000.fef213db5a66 no vethQCDY1N</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上, docker0 扮演着 52f811c5d3d6 container 这个容器的虚拟接口 vethQCDY1N interface 桥接的角色。</p><p><strong>使用特定范围的 IP</strong></p><p>Docker 会尝试寻找没有被主机使用的 ip 段，尽管它适用于大多数情况下，但是它不是万能的，有时候我们还是需要对 ip 进一步规划。Docker 允许你管理 docker0 桥接或者通过 -b 选项自定义桥接网卡，需要安装 bridge-utils 软件包。</p><p>基本步骤如下：</p><ul><li>ensure Docker is stopped # 确保 docker 的进程是停止的</li><li>create your own bridge (bridge0 for example) # 创建自定义网桥</li><li>assign a specific IP to this bridge # 给网桥分配特定的 ip</li><li>start Docker with the -b=bridge0 parameter # 以 -b 的方式指定网桥</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span># Stopping Docker and removing docker0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>$ sudo service docker stop</span></span>
<span class="line"><span>$ sudo ip link set dev docker0 down</span></span>
<span class="line"><span>$ sudo brctl delbr docker0</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Create our own bridge</span></span>
<span class="line"><span></span></span>
<span class="line"><span>$ sudo brctl addbr bridge0</span></span>
<span class="line"><span>$ sudo ip addr add 192.168.5.1/24 dev bridge0</span></span>
<span class="line"><span>$ sudo ip link set dev bridge0 up</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Confirming that our bridge is up and running</span></span>
<span class="line"><span></span></span>
<span class="line"><span>$ ip addr show bridge0</span></span>
<span class="line"><span>4: bridge0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state UP group default</span></span>
<span class="line"><span>    link/ether 66:38:d0:0d:76:18 brd ff:ff:ff:ff:ff:ff</span></span>
<span class="line"><span>    inet 192.168.5.1/24 scope global bridge0</span></span>
<span class="line"><span>       valid_lft forever preferred_lft forever</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Tell Docker about it and restart (on Ubuntu)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>$ echo &#39;DOCKER_OPTS=&quot;-b=bridge0&quot;&#39; &gt;&gt; /etc/default/docker</span></span>
<span class="line"><span>$ sudo service docker start</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参考文档: <a href="https://docs.docker.com/articles/networking/" target="_blank" rel="noopener noreferrer">Network Configuration</a></p><h3 id="_6-5-不同主机间容器通信" tabindex="-1"><a class="header-anchor" href="#_6-5-不同主机间容器通信"><span>6.5 不同主机间容器通信</span></a></h3><p>不同容器之间的通信可以借助于 pipework 这个工具：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ git clone https://github.com/jpetazzo/pipework.git</span></span>
<span class="line"><span>$ sudo cp -rp pipework/pipework /usr/local/bin/</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>安装相应依赖软件</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo apt-get install iputils-arping bridge-utils -y</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>桥接网络</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span># brctl show</span></span>
<span class="line"><span>bridge name     bridge id               STP enabled     interfaces</span></span>
<span class="line"><span>br0             8000.000c291412cd       no              eth0</span></span>
<span class="line"><span>docker0         8000.56847afe9799       no              vetheb48029</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以删除 docker0，直接把 docker 的桥接指定为 br0。也可以保留使用默认的配置，这样单主机容器之间的通信可以通过 docker0，而跨主机不同容器之间通过 pipework 新建 docker 容器的网卡桥接到 br0，这样跨主机容器之间就可以通信了。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># ubuntu</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> sudo</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> service</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> docker</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> stop</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> sudo</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> ip</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> link</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> set</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> dev</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> docker0</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> down</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> sudo</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> brctl</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> delbr</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> docker0</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> echo</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">DOCKER_OPTS=&quot;-b=br0&quot;</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &gt;&gt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> /etc/default/docker</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> sudo</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> service</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> docker</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> start</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># CentOS 7/RHEL 7</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> sudo</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> systemctl</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> stop</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> docker</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> sudo</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> ip</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> link</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> set</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> dev</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> docker0</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> down</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> sudo</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> brctl</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> delbr</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> docker0</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> cat</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> /etc/sysconfig/docker</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> |</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> grep</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">OPTIONS=</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">OPTIONS</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">--selinux-enabled</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> -b</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">br0</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> -H</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> fd://</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> sudo</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> systemctl</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> start</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> docker</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>pipework</strong></p><p>不同容器之间的通信可以借助于 pipework 这个工具给 docker 容器新建虚拟网卡并绑定 IP 桥接到 br0</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> git</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> clone</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> https://github.com/jpetazzo/pipework.git</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> sudo</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> cp</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -rp</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> pipework/pipework</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> /usr/local/bin/</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> pipework</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Syntax:</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">pipework</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">hostinterfac</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">e</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> [-i </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">containerinterface]</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">gues</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">t</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">ipadd</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">r</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">/</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">subne</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">t</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">[@default_gateway]</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> [macaddr]</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">@vlan</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">pipework</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">hostinterfac</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">e</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> [-i </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">containerinterface]</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">gues</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">t</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> dhcp</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> [macaddr]</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">@vlan</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">pipework</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> --wait</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> [-i </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">containerinterface]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果删除了默认的 docker0 桥接，把 docker 默认桥接指定到了 br0，则最好在创建容器的时候加上 --net=none，防止自动分配的 IP 在局域网中有冲突。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker run --rm -ti --net=none ubuntu:14.04 /bin/bash</span></span>
<span class="line"><span>root@a46657528059:/#</span></span>
<span class="line"><span>$                  # Ctrl-P + Ctrl-Q 回到宿主机 shell，容器 detach 状态</span></span>
<span class="line"><span>$ sudo docker  ps</span></span>
<span class="line"><span>CONTAINER ID    IMAGE          COMMAND       CREATED         STATUS          PORTS      NAMES</span></span>
<span class="line"><span>a46657528059    ubuntu:14.04   &quot;/bin/bash&quot;   4 minutes ago   Up 4 minutes               hungry_lalande</span></span>
<span class="line"><span>$ sudo pipework br0 -i eth0 a46657528059 192.168.115.10/24@192.168.115.2</span></span>
<span class="line"><span># 默认不指定网卡设备名，则默认添加为 eth1</span></span>
<span class="line"><span># 另外 pipework 不能添加静态路由，如果有需求则可以在 run 的时候加上 --privileged=true 权限在容器中手动添加，</span></span>
<span class="line"><span># 但这种安全性有缺陷，可以通过 ip netns 操作</span></span>
<span class="line"><span>$ sudo docker attach a46657528059</span></span>
<span class="line"><span>root@a46657528059:/# ifconfig eth0</span></span>
<span class="line"><span>eth0      Link encap:Ethernet  HWaddr 86:b6:6b:e8:2e:4d</span></span>
<span class="line"><span>          inet addr:192.168.115.10  Bcast:0.0.0.0  Mask:255.255.255.0</span></span>
<span class="line"><span>          inet6 addr: fe80::84b6:6bff:fee8:2e4d/64 Scope:Link</span></span>
<span class="line"><span>          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span></span>
<span class="line"><span>          RX packets:8 errors:0 dropped:0 overruns:0 frame:0</span></span>
<span class="line"><span>          TX packets:9 errors:0 dropped:0 overruns:0 carrier:0</span></span>
<span class="line"><span>          collisions:0 txqueuelen:1000</span></span>
<span class="line"><span>          RX bytes:648 (648.0 B)  TX bytes:690 (690.0 B)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>root@a46657528059:/# route -n</span></span>
<span class="line"><span>Kernel IP routing table</span></span>
<span class="line"><span>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span></span>
<span class="line"><span>0.0.0.0         192.168.115.2   0.0.0.0         UG    0      0        0 eth0</span></span>
<span class="line"><span>192.168.115.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 ip netns 添加静态路由，避免创建容器使用 --privileged=true 选项造成一些不必要的安全问题：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ docker inspect --format=&quot;&lt; .State.Pid &gt;&quot; a46657528059 # 获取指定容器 pid</span></span>
<span class="line"><span>6350</span></span>
<span class="line"><span>$ sudo ln -s /proc/6350/ns/net /var/run/netns/6350</span></span>
<span class="line"><span>$ sudo ip netns exec 6350 ip route add 192.168.0.0/16 dev eth0 via 192.168.115.2</span></span>
<span class="line"><span>$ sudo ip netns exec 6350 ip route    # 添加成功</span></span>
<span class="line"><span>192.168.0.0/16 via 192.168.115.2 dev eth0</span></span>
<span class="line"><span>... ...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在其它宿主机进行相应的配置，新建容器并使用 pipework 添加虚拟网卡桥接到 br0，测试通信情况即可。</p><p>另外，pipework 可以创建容器的 vlan 网络，这里不作过多的介绍了，官方文档已经写的很清楚了，可以查看以下两篇文章：</p><ul><li><a href="https://github.com/jpetazzo/pipework" target="_blank" rel="noopener noreferrer">Pipework 官方文档</a></li><li><a href="http://www.infoq.com/cn/articles/docker-network-and-pipework-open-source-explanation-practice" target="_blank" rel="noopener noreferrer">Docker 网络详解及 pipework 源码解读与实践</a></li></ul><h2 id="七、dockerfile" tabindex="-1"><a class="header-anchor" href="#七、dockerfile"><span>七、Dockerfile</span></a></h2><p>Docker 可以通过 Dockerfile 的内容来自动构建镜像。Dockerfile 是一个包含创建镜像所有命令的文本文件，通过 docker build 命令可以根据 Dockerfile 的内容构建镜像，在介绍如何构建之前先介绍下 Dockerfile 的基本语法结构。</p><p>Dockerfile 有以下指令选项:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>FROM</span></span>
<span class="line"><span>MAINTAINER</span></span>
<span class="line"><span>RUN</span></span>
<span class="line"><span>CMD</span></span>
<span class="line"><span>EXPOSE</span></span>
<span class="line"><span>ENV</span></span>
<span class="line"><span>ADD</span></span>
<span class="line"><span>COPY</span></span>
<span class="line"><span>ENTRYPOINT</span></span>
<span class="line"><span>VOLUME</span></span>
<span class="line"><span>USER</span></span>
<span class="line"><span>WORKDIR</span></span>
<span class="line"><span>ONBUILD</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_7-1-from" tabindex="-1"><a class="header-anchor" href="#_7-1-from"><span>7.1 FROM</span></a></h3><p>用法: <code>FROM &lt;image&gt;</code></p><ul><li>FROM 指定构建镜像的基础源镜像，如果本地没有指定的镜像，则会自动从 Docker 的公共库 pull 镜像下来。</li><li>FROM 必须是 Dockerfile 中非注释行的第一个指令，即一个 Dockerfile 从 FROM 语句开始。</li><li>FROM 可以在一个 Dockerfile 中出现多次，如果有需求在一个 Dockerfile 中创建多个镜像。 如果 FROM 语句没有指定镜像标签，则默认使用 latest 标签。</li></ul><h3 id="_7-2-maintainer" tabindex="-1"><a class="header-anchor" href="#_7-2-maintainer"><span>7.2 MAINTAINER</span></a></h3><p>用法: <code>MAINTAINER &lt;name&gt;</code></p><p>指定创建镜像的用户</p><h3 id="_7-3-run-有两种使用方式" tabindex="-1"><a class="header-anchor" href="#_7-3-run-有两种使用方式"><span>7.3 RUN 有两种使用方式</span></a></h3><p>RUN (the command is run in a shell - /bin/sh -c - shell form) RUN [“executable”, “param1”, “param2”] (exec form) 每条 RUN 指令将在当前镜像基础上执行指定命令，并提交为新的镜像，后续的 RUN 都在之前 RUN 提交后的镜像为基础，镜像是分层的，可以通过一个镜像的任何一个历史提交点来创建，类似源码的版本控制。</p><p>exec 方式会被解析为一个 JSON 数组，所以必须使用双引号而不是单引号。exec 方式不会调用一个命令 shell，所以也就不会继承相应的变量，如：</p><p><code>RUN [ &quot;echo&quot;, &quot;$HOME&quot; ]</code></p><p>这种方式是不会达到输出 HOME 变量的，正确的方式应该是这样的</p><p><code>RUN [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo&quot;, &quot;$HOME&quot; ]</code></p><p>RUN 产生的缓存在下一次构建的时候是不会失效的，会被重用，可以使用 --no-cache 选项，即 docker build --no-cache，如此便不会缓存。</p><h3 id="_7-4-cmd" tabindex="-1"><a class="header-anchor" href="#_7-4-cmd"><span>7.4 CMD</span></a></h3><p>CMD 有三种使用方式:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>CMD [“executable”,”param1”,”param2”] (exec form, this is the preferred form, 优先选择)</span></span>
<span class="line"><span>CMD [“param1”,”param2”] (as default parameters to ENTRYPOINT)</span></span>
<span class="line"><span>CMD command param1 param2 (shell form)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>CMD 指定在 Dockerfile 中只能使用一次，如果有多个，则只有最后一个会生效。</p><p>CMD 的目的是为了在启动容器时提供一个默认的命令执行选项。如果用户启动容器时指定了运行的命令，则会覆盖掉 CMD 指定的命令。</p><blockquote><p>CMD 会在启动容器的时候执行，build 时不执行，而 RUN 只是在构建镜像的时候执行，后续镜像构建完成之后，启动容器就与 RUN 无关了，这个初学者容易弄混这个概念，这里简单注解一下。</p></blockquote><h3 id="_7-5-expose" tabindex="-1"><a class="header-anchor" href="#_7-5-expose"><span>7.5 EXPOSE</span></a></h3><p><code>EXPOSE &lt;port&gt; [&lt;port&gt;...]</code></p><p>告诉 Docker 服务端容器对外映射的本地端口，需要在 docker run 的时候使用 -p 或者 -P 选项生效。</p><h3 id="_7-6-env" tabindex="-1"><a class="header-anchor" href="#_7-6-env"><span>7.6 ENV</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>ENV &lt;key&gt; &lt;value&gt;       # 只能设置一个变量</span></span>
<span class="line"><span>ENV &lt;key&gt;=&lt;value&gt; ...   # 允许一次设置多个变量</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>指定一个环节变量，会被后续 RUN 指令使用，并在容器运行时保留。</p><p>例子:</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">ENV</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> myName=</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">John Doe</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> myDog=Rex</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">\\ </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">The</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">\\ </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Dog</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> \\</span></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">    myCat=fluffy</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 等同于</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">ENV</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> myName</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> John</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> Doe</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">ENV</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> myDog</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> Rex</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> The</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> Dog</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">ENV</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> myCat</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> fluffy</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_7-7-add" tabindex="-1"><a class="header-anchor" href="#_7-7-add"><span>7.7 ADD</span></a></h3><p><code>ADD &lt;src&gt;... &lt;dest&gt;</code></p><p>ADD 复制本地主机文件、目录或者远程文件 URLS 从 src 并且添加到容器指定路径中 dest。</p><p>src 支持通过 GO 的正则模糊匹配，具体规则可参见 Go filepath.Match</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>ADD hom* /mydir/        # adds all files starting with &quot;hom&quot;</span></span>
<span class="line"><span>ADD hom?.txt /mydir/    # ? is replaced with any single character</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>dest 路径可以绝对路径也可以是相对于工作路径的相对路径，如果 dest 不存在，会自动创建对应目录</li><li>src 路径必须是 Dockerfile 所在路径的相对路径，或路径是 build 上下文 context 的路径或子路径。</li><li>src 如果是一个目录，只会复制目录下的内容，而目录本身则不会被复制</li></ul><h3 id="_7-7-copy" tabindex="-1"><a class="header-anchor" href="#_7-7-copy"><span>7.7 COPY</span></a></h3><p><code>COPY &lt;src&gt;... &lt;dest&gt;</code></p><p>COPY 复制新文件或者目录从 src 添加到容器指定路径中 dest。用法同 ADD，唯一的不同是不能指定远程文件 URLS。</p><h3 id="_7-8-entrypoint" tabindex="-1"><a class="header-anchor" href="#_7-8-entrypoint"><span>7.8 ENTRYPOINT</span></a></h3><p>有2中执行方式：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>ENTRYPOINT [“executable”, “param1”, “param2”] (the preferred exec form，优先选择)</span></span>
<span class="line"><span>ENTRYPOINT command param1 param2 (shell form)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖，而 CMD 是可以被覆盖的。如果需要覆盖，则可以使用 docker run --entrypoint 选项。</p><p>每个 Dockerfile 中只能有一个 ENTRYPOINT，当指定多个时，只有最后一个生效。</p><p><strong>Exec form ENTRYPOINT 例子</strong></p><p>通过 ENTRYPOINT 使用 exec form 方式设置稳定的默认命令和选项，而使用 CMD 添加默认之外经常被改动的选项。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>FROM ubuntu</span></span>
<span class="line"><span>ENTRYPOINT [&quot;top&quot;, &quot;-b&quot;]</span></span>
<span class="line"><span>CMD [&quot;-c&quot;]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过 Dockerfile 使用 ENTRYPOINT 展示前台运行 Apache 服务</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>FROM debian:stable</span></span>
<span class="line"><span>RUN apt-get update &amp;&amp; apt-get install -y --force-yes apache2</span></span>
<span class="line"><span>EXPOSE 80 443</span></span>
<span class="line"><span>VOLUME [&quot;/var/www&quot;, &quot;/var/log/apache2&quot;, &quot;/etc/apache2&quot;]</span></span>
<span class="line"><span>ENTRYPOINT [&quot;/usr/sbin/apache2ctl&quot;, &quot;-D&quot;, &quot;FOREGROUND&quot;]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Shell form ENTRYPOINT 例子</strong></p><p>这种方式会在 /bin/sh -c 中执行，会忽略任何 CMD 或者 docker run 命令行选项，为了确保 docker stop 能够停止长时间运行 ENTRYPOINT 的容器，确保执行的时候使用 exec 选项。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>FROM ubuntu</span></span>
<span class="line"><span>ENTRYPOINT exec top -b</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果在 ENTRYPOINT 忘记使用 exec 选项，则可以使用 CMD 补上:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>FROM ubuntu</span></span>
<span class="line"><span>ENTRYPOINT top -b</span></span>
<span class="line"><span>CMD --ignored-param1 # --ignored-param2 ... --ignored-param3 ... 依此类推</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_7-9-volume" tabindex="-1"><a class="header-anchor" href="#_7-9-volume"><span>7.9 VOLUME</span></a></h3><p><code>VOLUME [&quot;/data&quot;]</code></p><p>创建一个可以从本地主机或其他容器挂载的挂载点，后续具体介绍。</p><h3 id="_7-10-user" tabindex="-1"><a class="header-anchor" href="#_7-10-user"><span>7.10 USER</span></a></h3><p><code>USER daemon</code></p><p>指定运行容器时的用户名或 UID，后续的 RUN、CMD、ENTRYPOINT 也会使用指定用户。</p><h3 id="_7-11-workdir" tabindex="-1"><a class="header-anchor" href="#_7-11-workdir"><span>7.11 WORKDIR</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>WORKDIR /path/to/workdir</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>为后续的 RUN、CMD、ENTRYPOINT 指令配置工作目录。可以使用多个 WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>WORKDIR /a</span></span>
<span class="line"><span>WORKDIR b</span></span>
<span class="line"><span>WORKDIR c</span></span>
<span class="line"><span>RUN pwd</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最终路径是 /a/b/c。</p><p>WORKDIR 指令可以在 ENV 设置变量之后调用环境变量:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>ENV DIRPATH /path</span></span>
<span class="line"><span>WORKDIR $DIRPATH/$DIRNAME</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>最终路径则为 /path/$DIRNAME。</p><h3 id="_7-12-onbuild" tabindex="-1"><a class="header-anchor" href="#_7-12-onbuild"><span>7.12 ONBUILD</span></a></h3><p><code>ONBUILD [INSTRUCTION]</code> 配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。</p><p>例如，Dockerfile 使用如下的内容创建了镜像 image-A：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>[...]</span></span>
<span class="line"><span>ONBUILD ADD . /app/src</span></span>
<span class="line"><span>ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span></span>
<span class="line"><span>[...]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果基于 image-A 创建新的镜像时，新的 Dockerfile 中使用 FROM image-A 指定基础镜像时，会自动执行 ONBUILD 指令内容，等价于在后面添加了两条指令。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span># Automatically run the following</span></span>
<span class="line"><span>ADD . /app/src</span></span>
<span class="line"><span>RUN /usr/local/bin/python-build --dir /app/src</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 ONBUILD 指令的镜像，推荐在标签中注明，例如 ruby:1.9-onbuild。</p><h3 id="_7-13-dockerfile-examples" tabindex="-1"><a class="header-anchor" href="#_7-13-dockerfile-examples"><span>7.13 Dockerfile Examples</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span># Nginx</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># VERSION               0.0.1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>FROM      ubuntu</span></span>
<span class="line"><span>MAINTAINER Victor Vieux &lt;victor@docker.com&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>RUN apt-get update &amp;&amp; apt-get install -y inotify-tools nginx apache2 openssh-server</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Firefox over VNC</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># VERSION               0.3</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>FROM ubuntu</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Install vnc, xvfb in order to create a &#39;fake&#39; display and firefox</span></span>
<span class="line"><span>RUN apt-get update &amp;&amp; apt-get install -y x11vnc xvfb firefox</span></span>
<span class="line"><span>RUN mkdir ~/.vnc</span></span>
<span class="line"><span># Setup a password</span></span>
<span class="line"><span>RUN x11vnc -storepasswd 1234 ~/.vnc/passwd</span></span>
<span class="line"><span># Autostart firefox (might not be the best way, but it does the trick)</span></span>
<span class="line"><span>RUN bash -c &#39;echo &quot;firefox&quot; &gt;&gt; /.bashrc&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>EXPOSE 5900</span></span>
<span class="line"><span>CMD    [&quot;x11vnc&quot;, &quot;-forever&quot;, &quot;-usepw&quot;, &quot;-create&quot;]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span># Multiple images example</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># VERSION               0.1</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>FROM ubuntu</span></span>
<span class="line"><span>RUN echo foo &gt; bar</span></span>
<span class="line"><span># Will output something like ===&gt; 907ad6c2736f</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>FROM ubuntu</span></span>
<span class="line"><span>RUN echo moo &gt; oink</span></span>
<span class="line"><span># Will output something like ===&gt; 695d7793cbe4</span></span>
<span class="line"><span></span></span>
<span class="line"><span># You᾿ll now have two images, 907ad6c2736f with /bar, and 695d7793cbe4 with</span></span>
<span class="line"><span># /oink.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_7-14-docker-build" tabindex="-1"><a class="header-anchor" href="#_7-14-docker-build"><span>7.14 docker build</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ docker build -t &lt;container-name&gt;:&lt;tag&gt; -f Dockerfile .</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>参考文档: <a href="https://docs.docker.com/reference/builder/" target="_blank" rel="noopener noreferrer">Dockerfile Reference</a></p><h3 id="_7-15-dockerfile-最佳实践" tabindex="-1"><a class="header-anchor" href="#_7-15-dockerfile-最佳实践"><span>7.15 dockerfile 最佳实践</span></a></h3><ul><li><p>使用 .dockerignore 文件 为了在 docker build 过程中更快上传和更加高效，应该使用一个 .dockerignore 文件用来排除构建镜像时不需要的文件或目录。例如,除非 .git 在构建过程中需要用到，否则你应该将它添加到 .dockerignore 文件中，这样可以节省很多时间。</p></li><li><p>避免安装不必要的软件包 为了降低复杂性、依赖性、文件大小以及构建时间，应该避免安装额外的或不必要的包。例如，不需要在一个数据库镜像中安装一个文本编辑器。</p></li><li><p>每个容器都跑一个进程 在大多数情况下，一个容器应该只单独跑一个程序。解耦应用到多个容器使其更容易横向扩展和重用。如果一个服务依赖另外一个服务，可以参考 Linking Containers Together。</p></li><li><p>最小化层 我们知道每执行一个指令，都会有一次镜像的提交，镜像是分层的结构，对于 Dockerfile，应该找到可读性和最小化层之间的平衡。</p></li><li><p>多行参数排序 如果可能，通过字母顺序来排序，这样可以避免安装包的重复并且更容易更新列表，另外可读性也会更强，添加一个空行使用 \\ 换行:</p></li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>RUN apt-get update &amp;&amp; apt-get install -y \\</span></span>
<span class="line"><span>  bzr \\</span></span>
<span class="line"><span>  cvs \\</span></span>
<span class="line"><span>  git \\</span></span>
<span class="line"><span>  mercurial \\</span></span>
<span class="line"><span>  subversion</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>创建缓存 镜像构建过程中会按照 Dockerfile 的顺序依次执行，每执行一次指令 Docker 会寻找是否有存在的镜像缓存可复用，如果没有则创建新的镜像。如果不想使用缓存，则可以在 docker build 时添加 --no-cache=true 选项。</li></ul><p>从基础镜像开始就已经在缓存中了，下一个指令会对比所有的子镜像寻找是否执行相同的指令，如果没有则缓存失效。在大多数情况下只对比 Dockerfile 指令和子镜像就足够了。ADD 和 COPY 指令除外，执行 ADD 和 COPY 时存放到镜像的文件也是需要检查的，完成一个文件的校验之后再利用这个校验在缓存中查找，如果检测的文件改变则缓存失效。RUN apt-get -y update 命令只检查命令是否匹配，如果匹配就不会再执行更新了。</p><blockquote><p>为了有效地利用缓存，你需要保持你的 Dockerfile 一致，并且尽量在末尾修改。</p></blockquote><ul><li><p>Dockerfile 指令</p><ul><li><p>FROM: 只要可能就使用官方镜像库作为基础镜像</p></li><li><p>RUN: 为保持可读性、方便理解、可维护性，把长或者复杂的 RUN 语句使用 \\ 分隔符分成多行</p><ul><li>不建议 RUN apt-get update 独立成行，否则如果后续包有更新，那么也不会再执行更新</li><li>避免使用 RUN apt-get upgrade 或者 dist-upgrade，很多必要的包在一个非 privileged 权限的容器里是无法升级的。如果知道某个包更新，使用 apt-get install -y xxx</li><li>标准写法</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>RUN apt-get update &amp;&amp; apt-get install -y package-bar package-foo</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>例子:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>RUN apt-get update &amp;&amp; apt-get install -y \\</span></span>
<span class="line"><span>    aufs-tools \\</span></span>
<span class="line"><span>    automake \\</span></span>
<span class="line"><span>    btrfs-tools \\</span></span>
<span class="line"><span>    build-essential \\</span></span>
<span class="line"><span>    curl \\</span></span>
<span class="line"><span>    dpkg-sig \\</span></span>
<span class="line"><span>    git \\</span></span>
<span class="line"><span>    iptables \\</span></span>
<span class="line"><span>    libapparmor-dev \\</span></span>
<span class="line"><span>    libcap-dev \\</span></span>
<span class="line"><span>    libsqlite3-dev \\</span></span>
<span class="line"><span>    lxc=1.0* \\</span></span>
<span class="line"><span>    mercurial \\</span></span>
<span class="line"><span>    parallel \\</span></span>
<span class="line"><span>    reprepro \\</span></span>
<span class="line"><span>    ruby1.9.1 \\</span></span>
<span class="line"><span>    ruby1.9.1-dev \\</span></span>
<span class="line"><span>    s3cmd=1.1.0*</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>CMD: 推荐使用 CMD [“executable”, “param1”, “param2”…] 这种格式，CMD [“param”, “param”] 则配合 ENTRYPOINT 使用</p></li><li><p>EXPOSE: Dockerfile 指定要公开的端口，使用 docker run 时指定映射到宿主机的端口即可</p></li><li><p>ENV: 为了使新的软件更容易运行，可以使用 ENV 更新 PATH 变量。如 ENV PATH /usr/local/nginx/bin:$PATH 确保 CMD [&quot;nginx&quot;] 即可运行</p></li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>ENV 也可以这样定义变量：</span></span>
<span class="line"><span></span></span>
<span class="line"><span>ENV PG_MAJOR 9.3</span></span>
<span class="line"><span>ENV PG_VERSION 9.3.4</span></span>
<span class="line"><span>RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …</span></span>
<span class="line"><span>ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>ADD or COPY: ADD 比 COPY 多一些特性「tar 文件自动解包和支持远程 URL」，不推荐添加远程 URL</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span># 如不推荐这种方式:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>ADD http://example.com/big.tar.xz /usr/src/things/</span></span>
<span class="line"><span>RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things</span></span>
<span class="line"><span>RUN make -C /usr/src/things all</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 推荐使用 curl 或者 wget 替换，使用如下方式:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>RUN mkdir -p /usr/src/things \\</span></span>
<span class="line"><span>    &amp;&amp; curl -SL http://example.com/big.tar.gz \\</span></span>
<span class="line"><span>    | tar -xJC /usr/src/things \\</span></span>
<span class="line"><span>    &amp;&amp; make -C /usr/src/things all</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 如果不需要添加 tar 文件，推荐使用 COPY。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>参考文档:</p><ul><li><a href="https://docs.docker.com/articles/dockerfile_best-practices/" target="_blank" rel="noopener noreferrer">Best practices for writing Dockerfiles</a></li><li><a href="http://dockerone.com/article/131" target="_blank" rel="noopener noreferrer">Dockerfile最佳实践（一）</a></li><li><a href="http://dockerone.com/article/132" target="_blank" rel="noopener noreferrer">Dockerfile最佳实践（二）</a></li></ul><h2 id="八、容器数据管理" tabindex="-1"><a class="header-anchor" href="#八、容器数据管理"><span>八、容器数据管理</span></a></h2><p>docker管理数据的方式有两种：</p><ul><li>数据卷</li><li>数据卷容器</li></ul><h3 id="_8-1-数据卷" tabindex="-1"><a class="header-anchor" href="#_8-1-数据卷"><span>8.1 数据卷</span></a></h3><p>数据卷是一个或多个容器专门指定绕过 Union File System 的目录，为持续性或共享数据提供一些有用的功能：</p><ul><li>数据卷可以在容器间共享和重用</li><li>数据卷数据改变是直接修改的</li><li>数据卷数据改变不会被包括在容器中</li><li>数据卷是持续性的，直到没有容器使用它们</li></ul><h4 id="添加一个数据卷" tabindex="-1"><a class="header-anchor" href="#添加一个数据卷"><span>添加一个数据卷</span></a></h4><p>你可以使用 -v 选项添加一个数据卷，或者可以使用多次 -v 选项为一个 docker 容器运行挂载多个数据卷。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker run --name data -v /data -t -i ubuntu:14.04 /bin/bash</span></span>
<span class="line"><span># 创建数据卷绑定到到新建容器，新建容器中会创建 /data 数据卷</span></span>
<span class="line"><span>bash-4.1# ls -ld /data/</span></span>
<span class="line"><span>drwxr-xr-x 2 root root 4096 Jul 23 06:59 /data/</span></span>
<span class="line"><span>bash-4.1# df -Th</span></span>
<span class="line"><span>Filesystem    Type    Size  Used Avail Use% Mounted on</span></span>
<span class="line"><span>... ...</span></span>
<span class="line"><span>              ext4     91G  4.6G   82G   6% /data</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建的数据卷可以通过 docker inspect 获取宿主机对应路径</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker inspect data</span></span>
<span class="line"><span>... ...</span></span>
<span class="line"><span>    &quot;Volumes&quot;: {</span></span>
<span class="line"><span>        &quot;/data&quot;: &quot;/var/lib/docker/vfs/dir/151de401d268226f96d824fdf444e77a4500aed74c495de5980c807a2ffb7ea9&quot;</span></span>
<span class="line"><span>    }, # 可以看到创建的数据卷宿主机路径</span></span>
<span class="line"><span>... ...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者直接指定获取</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker inspect --format=&quot;&lt; .Volumes &gt;&quot; data</span></span>
<span class="line"><span>map[/data: /var/lib/docker/vfs/dir/151de401d268226f96d824fdf444e77a4500aed74c495de5980c807a2ffb7ea9]</span></span>
<span class="line"><span>挂载宿主机目录为一个数据卷</span></span>
<span class="line"><span>-v 选项除了可以创建卷，也可以挂载当前主机的一个目录到容器中。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>$ sudo docker run --name web -v /source/:/web -t -i ubuntu:14.04 /bin/bash</span></span>
<span class="line"><span>bash-4.1# ls -ld /web/</span></span>
<span class="line"><span>drwxr-xr-x 2 root root 4096 Jul 23 06:59 /web/</span></span>
<span class="line"><span>bash-4.1# df -Th</span></span>
<span class="line"><span>... ...</span></span>
<span class="line"><span>              ext4     91G  4.6G   82G   6% /web</span></span>
<span class="line"><span>bash-4.1# exit</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>默认挂载卷是可读写的，可以在挂载时指定只读</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker run --rm --name test -v /source/:/test:ro -t -i ubuntu:14.04 /bin/bash</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_8-2-创建和挂载一个数据卷容器" tabindex="-1"><a class="header-anchor" href="#_8-2-创建和挂载一个数据卷容器"><span>8.2 创建和挂载一个数据卷容器</span></a></h3><p>如果你有一些持久性的数据并且想在容器间共享，或者想用在非持久性的容器上，最好的方法是创建一个数据卷容器，然后从此容器上挂载数据。</p><h4 id="创建数据卷容器" tabindex="-1"><a class="header-anchor" href="#创建数据卷容器"><span>创建数据卷容器</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker run -t -i -d -v /test --name test ubuntu:14.04 echo hello</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>使用 --volumes-from 选项在另一个容器中挂载 /test 卷。不管 test 容器是否运行，其它容器都可以挂载该容器数据卷，当然如果只是单独的数据卷是没必要运行容器的。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker run -t -i -d --volumes-from test --name test1 ubuntu:14.04 /bin/bash</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>添加另一个容器</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker run -t -i -d --volumes-from test --name test2 ubuntu:14.04 /bin/bash</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>也可以继承其它挂载有 /test 卷的容器</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker run -t -i -d --volumes-from test1 --name test3 ubuntu:14.04 /bin/bash</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_8-3-备份、恢复或迁移数据卷" tabindex="-1"><a class="header-anchor" href="#_8-3-备份、恢复或迁移数据卷"><span>8.3 备份、恢复或迁移数据卷</span></a></h3><h4 id="备份" tabindex="-1"><a class="header-anchor" href="#备份"><span>备份</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker run --rm --volumes-from test -v $(pwd):/backup ubuntu:14.04 tar cvf /backup/test.tar /test</span></span>
<span class="line"><span>tar: Removing leading \`/&#39; from member names</span></span>
<span class="line"><span>/test/</span></span>
<span class="line"><span>/test/b</span></span>
<span class="line"><span>/test/d</span></span>
<span class="line"><span>/test/c</span></span>
<span class="line"><span>/test/a</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动一个新的容器并且从 test 容器中挂载卷，然后挂载当前目录到容器中为 backup，并备份 test 卷中所有的数据为 test.tar，执行完成之后删除容器 --rm，此时备份就在当前的目录下，名为 test.tar。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ ls        # 宿主机当前目录下产生了 test 卷的备份文件 test.tar</span></span>
<span class="line"><span>test.tar</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="恢复" tabindex="-1"><a class="header-anchor" href="#恢复"><span>恢复</span></a></h4><p>你可以恢复给同一个容器或者另外的容器，新建容器并解压备份文件到新的容器数据卷</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker run -t -i -d -v /test --name test4 ubuntu:14.04  /bin/bash</span></span>
<span class="line"><span>$ sudo docker run --rm --volumes-from test4 -v $(pwd):/backup ubuntu:14.04 tar xvf /backup/test.tar -C /</span></span>
<span class="line"><span># 恢复之前的文件到新建卷中，执行完后自动删除容器</span></span>
<span class="line"><span>test/</span></span>
<span class="line"><span>test/b</span></span>
<span class="line"><span>test/d</span></span>
<span class="line"><span>test/c</span></span>
<span class="line"><span>test/a</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_8-4-删除-volumes" tabindex="-1"><a class="header-anchor" href="#_8-4-删除-volumes"><span>8.4 删除 Volumes</span></a></h3><p>Volume 只有在下列情况下才能被删除：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>docker rm -v 删除容器时添加了 -v 选项</span></span>
<span class="line"><span>docker run --rm 运行容器时添加了 --rm 选项</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>否则，会在 /var/lib/docker/vfs/dir 目录中遗留很多不明目录。</p><p>参考文档：</p><ul><li><a href="http://docs.docker.com/userguide/dockervolumes/#data-volumes" target="_blank" rel="noopener noreferrer">Managing Data in Containers</a></li><li><a href="http://dockerone.com/article/128" target="_blank" rel="noopener noreferrer">深入理解Docker Volume（一）</a></li><li><a href="http://dockerone.com/article/129" target="_blank" rel="noopener noreferrer">深入理解Docker Volume（二）</a></li></ul><h2 id="九、链接容器" tabindex="-1"><a class="header-anchor" href="#九、链接容器"><span>九、链接容器</span></a></h2><p>docker 允许把多个容器连接在一起，相互交互信息。docker 链接会创建一种容器父子级别的关系，其中父容器可以看到其子容器提供的信息。</p><h3 id="_9-1-容器命名" tabindex="-1"><a class="header-anchor" href="#_9-1-容器命名"><span>9.1 容器命名</span></a></h3><p>在创建容器时，如果不指定容器的名字，则默认会自动创建一个名字，这里推荐给容器命名：</p><p>1、给容器命名方便记忆，如命名运行 web 应用的容器为 web 2、为 docker 容器提供一个参考，允许方便其他容器调用，如把容器 web 链接到容器 db 可以通过 --name 选项给容器自定义命名：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker run -d -t -i --name test ubuntu:14.04 bash</span></span>
<span class="line"><span>$ sudo docker  inspect --format=&quot;&lt;.Nmae&gt;&quot; test</span></span>
<span class="line"><span>/test</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>注：容器名称必须唯一，即你只能命名一个叫 test 的容器。如果你想复用容器名，则必须在创建新的容器前通过 docker rm 删除旧的容器或者创建容器时添加 --rm 选项。</p></blockquote><h3 id="_9-2-链接容器" tabindex="-1"><a class="header-anchor" href="#_9-2-链接容器"><span>9.2 链接容器</span></a></h3><p>链接允许容器间安全通信，使用 --link 选项创建链接。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker run -d --name db training/postgres</span></span>
<span class="line"><span># 基于 training/postgres 镜像创建一个名为 db 的容器，然后下面创建一个叫做 web 的容器，并且将它与 db 相互连接在一起</span></span>
<span class="line"><span></span></span>
<span class="line"><span>$ sudo docker run -d -P --name web --link db:db training/webapp python app.py</span></span>
<span class="line"><span># --link &lt;name or id&gt;:alias 选项指定链接到的容器。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看 web 容器的链接关系:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker inspect -f &quot;&lt; .HostConfig.Links &gt;&quot; web</span></span>
<span class="line"><span>[/db:/web/db]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到 web 容器被链接到 db 容器为 /web/db，这允许 web 容器访问 db 容器的信息。</p><p>容器之间的链接实际做了什么？一个链接允许一个源容器提供信息访问给一个接收容器。在本例中，web 容器作为一个接收者，允许访问源容器 db 的相关服务信息。Docker 创建了一个安全隧道而不需要对外公开任何端口给外部容器，因此不需要在创建容器的时候添加 -p 或 -P 指定对外公开的端口，这也是链接容器的最大好处，本例为 PostgreSQL 数据库。</p><p>Docker 主要通过以下两个方式提供连接信息给接收容器：</p><ul><li>环境变量</li><li>更新 /etc/hosts 文件</li></ul><h4 id="环境变量" tabindex="-1"><a class="header-anchor" href="#环境变量"><span>环境变量</span></a></h4><p>当两个容器链接，Docker 会在目标容器上设置一些环境变量，以获取源容器的相关信息。</p><p>首先，Docker 会在每个通过 --link 选项指定别名的目标容器上设置一个 [alias]_NAME 环境变量。如果一个名为 web 的容器通过 --link db:webdb 被链接到一个名为 db 的数据库容器，那么 web 容器上会设置一个环境变量为 WEBDB_NAME=/web/webdb.</p><p>以之前的为例，Docker 还会设置端口变量:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker run --rm --name web2 --link db:db training/webapp env</span></span>
<span class="line"><span>. . .</span></span>
<span class="line"><span>DB_NAME=/web2/db</span></span>
<span class="line"><span>DB_PORT=tcp://172.17.0.5:5432</span></span>
<span class="line"><span>DB_PORT_5432_TCP=tcp://172.17.0.5:5432  # &lt;name&gt;_PORT_&lt;port&gt;_&lt;protocol&gt; 协议可以是 TCP 或 UDP</span></span>
<span class="line"><span>DB_PORT_5432_TCP_PROTO=tcp</span></span>
<span class="line"><span>DB_PORT_5432_TCP_PORT=5432</span></span>
<span class="line"><span>DB_PORT_5432_TCP_ADDR=172.17.0.5</span></span>
<span class="line"><span>. . .</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>注：这些环境变量只设置给容器中的第一个进程，类似一些守护进程 (如 sshd ) 当他们派生 shells 时会清除这些变量</p></blockquote><h4 id="更新-etc-hosts-文件" tabindex="-1"><a class="header-anchor" href="#更新-etc-hosts-文件"><span>更新 /etc/hosts 文件</span></a></h4><p>除了环境变量，Docker 会在目标容器上添加相关主机条目到 /etc/hosts 中，上例中就是 web 容器。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo docker run -t -i --rm --link db:db training/webapp /bin/bash</span></span>
<span class="line"><span>root@aed84ee21bde:/opt/webapp# cat /etc/hosts</span></span>
<span class="line"><span>172.17.0.7  aed84ee21bde</span></span>
<span class="line"><span>. . .</span></span>
<span class="line"><span>172.17.0.5  db</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>/etc/host 文件在源容器被重启之后会自动更新 IP 地址，而环境变量中的 IP 地址则不会自动更新的。</p><h2 id="十、构建私有库" tabindex="-1"><a class="header-anchor" href="#十、构建私有库"><span>十、构建私有库</span></a></h2><p>Docker 官方提供了 docker registry 的构建方法 docker-registry</p><h3 id="_10-1-快速构建" tabindex="-1"><a class="header-anchor" href="#_10-1-快速构建"><span>10.1 快速构建</span></a></h3><p>快速构建 docker registry 通过以下两步:</p><ul><li>安装 docker</li><li>运行 registry: docker run -p 5000:5000 registry 这种方法通过 Docker hub 使用官方镜像 <a href="https://registry.hub.docker.com/_/registry/" target="_blank" rel="noopener noreferrer">official image from the Docker hub</a></li></ul><h3 id="_10-2-不使用容器构建-registry" tabindex="-1"><a class="header-anchor" href="#_10-2-不使用容器构建-registry"><span>10.2 不使用容器构建 registry</span></a></h3><h4 id="安装必要的软件" tabindex="-1"><a class="header-anchor" href="#安装必要的软件"><span>安装必要的软件</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ sudo apt-get install build-essential python-dev libevent-dev python-pip liblzma-dev</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="配置-docker-registry" tabindex="-1"><a class="header-anchor" href="#配置-docker-registry"><span>配置 docker-registry</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>sudo pip install docker-registry</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>或者 使用 github clone 手动安装</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>$ git clone https://github.com/dotcloud/docker-registry.git</span></span>
<span class="line"><span>$ cd docker-registry/</span></span>
<span class="line"><span>$ cp config/config_sample.yml config/config.yml</span></span>
<span class="line"><span>$ mkdir /data/registry -p</span></span>
<span class="line"><span>$ pip install .</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="运行" tabindex="-1"><a class="header-anchor" href="#运行"><span>运行</span></a></h4><p><code>docker-registry</code></p><h4 id="高级启动方式-不推荐" tabindex="-1"><a class="header-anchor" href="#高级启动方式-不推荐"><span>高级启动方式 [不推荐]</span></a></h4><p>使用 gunicorn 控制:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>gunicorn -c contrib/gunicorn_config.py docker_registry.wsgi:application</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>或者对外监听开放</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>gunicorn --access-logfile - --error-logfile - -k gevent -b 0.0.0.0:5000 -w 4 --max-requests 100 docker_registry.wsgi:application</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_10-3-提交指定容器到私有库" tabindex="-1"><a class="header-anchor" href="#_10-3-提交指定容器到私有库"><span>10.3 提交指定容器到私有库</span></a></h3><p>$ docker tag ubuntu:12.04 私有库IP:5000/ubuntu:12.04 $ docker push 私有库IP:5000/ubuntu 更多的配置选项推荐阅读官方文档:</p><ul><li><a href="https://github.com/docker/docker-registry/blob/master/README.md" target="_blank" rel="noopener noreferrer">Docker-Registry README</a></li><li><a href="https://github.com/docker/docker-registry/blob/master/ADVANCED.md" target="_blank" rel="noopener noreferrer">Docker-Registry advanced use</a></li></ul>`,358)])])}const o=i(t,[["render",c]]),u=JSON.parse('{"path":"/pages/c6b8a0/","title":"Docker 知识大全","lang":"zh-CN","frontmatter":{"title":"Docker 知识大全","tags":["自动化运维","Docker"],"permalink":"/pages/c6b8a0/","createTime":"2023/09/08 17:36:02","description":"原文地址：https://blog.opskumu.com/docker.html 本文对原文进行了更新和补充，转载备查。 一、Docker 简介 Docker 是一种轻量级的虚拟化技术，是一种Linux容器（Linux Containers，缩写为 LXC）技术的封装。 大多数人可能知道虚拟机，可以在一台硬件机器上虚拟出另一台计算机，有它自己的cpu...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Docker 知识大全\\",\\"image\\":[\\"https://pylixm.top/imgs/docker-on-linux.png\\",\\"https://pylixm.top/imgs/docker-execdriver-diagram.png\\",\\"https://pylixm.top/imgs/docker-networking.jpg\\",\\"https://pylixm.top/imgs/docker-vethbridge.png\\"],\\"dateModified\\":\\"2025-09-30T08:57:49.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://pylixm.top/pages/c6b8a0/"}],["meta",{"property":"og:site_name","content":"底层逻辑"}],["meta",{"property":"og:title","content":"Docker 知识大全"}],["meta",{"property":"og:description","content":"原文地址：https://blog.opskumu.com/docker.html 本文对原文进行了更新和补充，转载备查。 一、Docker 简介 Docker 是一种轻量级的虚拟化技术，是一种Linux容器（Linux Containers，缩写为 LXC）技术的封装。 大多数人可能知道虚拟机，可以在一台硬件机器上虚拟出另一台计算机，有它自己的cpu..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://pylixm.top/imgs/docker-on-linux.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-30T08:57:49.000Z"}],["meta",{"property":"article:tag","content":"Docker"}],["meta",{"property":"article:tag","content":"自动化运维"}],["meta",{"property":"article:modified_time","content":"2025-09-30T08:57:49.000Z"}]]},"readingTime":{"minutes":39.05,"words":11715},"git":{"createdTime":1759222669000,"updatedTime":1759222669000,"contributors":[{"name":"pylixm","username":"pylixm","email":"pyli.xm@gmail.com","commits":1,"avatar":"https://avatars.githubusercontent.com/pylixm?v=4","url":"https://github.com/pylixm"}]},"autoDesc":true,"filePathRelative":"04.云原生/01.docker/03.Docker-all.md","headers":[],"categoryList":[{"id":"e467f5","sort":4,"name":"云原生"},{"id":"219fa0","sort":1,"name":"docker"}]}');export{o as comp,u as data};
