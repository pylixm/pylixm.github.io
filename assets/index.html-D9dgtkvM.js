import{_ as t,c as i,b as n,a as o,e as l,w as p,r,o as d,d as s}from"./app-Cpl7-wzY.js";const m={};function h(c,e){const a=r("VPLink");return d(),i("div",null,[n("p",null,[l(a,{href:"/pages/39558d/"},{default:p(()=>[...e[0]||(e[0]=[s("其他章节索引页",-1)])]),_:1})]),e[1]||(e[1]=o('<h1 id="第六章-model-最佳实践" tabindex="-1"><a class="header-anchor" href="#第六章-model-最佳实践"><span>第六章 model 最佳实践</span></a></h1><h2 id="当app的model过多时-拆分app" tabindex="-1"><a class="header-anchor" href="#当app的model过多时-拆分app"><span>当app的model过多时，拆分app</span></a></h2><p>当app的model过多时，说明这个app的功能够大，此时就需要我们拆分app了。</p><h2 id="模型继承的使用" tabindex="-1"><a class="header-anchor" href="#模型继承的使用"><span>模型继承的使用</span></a></h2><ul><li>抽象基类（区别django的抽象基类和python的抽象类）</li><li>多表继承（尽量不要使用，效率低下）</li><li>代理模式</li></ul><h2 id="数据模型的规范化" tabindex="-1"><a class="header-anchor" href="#数据模型的规范化"><span>数据模型的规范化</span></a></h2><p>同数据库设计的规范化，推荐阅读：</p><ul><li>http://en.wikipedia.org/wiki/Database_normalization</li><li>http://en.wikibooks.org/wiki/Relational_Database_Design/Normalization</li></ul><h2 id="使用-null-和-blank时注意" tabindex="-1"><a class="header-anchor" href="#使用-null-和-blank时注意"><span>使用 Null 和 Blank时注意</span></a></h2><p>在字段上设置null=True 和 the blank=True，他们默认是False。</p><h2 id="使用-genericipaddressfield-代替ipaddressfield-后者将要移除。" tabindex="-1"><a class="header-anchor" href="#使用-genericipaddressfield-代替ipaddressfield-后者将要移除。"><span>使用 GenericIPAddressField 代替IPAddressField，后者将要移除。</span></a></h2><h2 id="使用-binaryfield-字段注意" tabindex="-1"><a class="header-anchor" href="#使用-binaryfield-字段注意"><span>使用 BinaryField 字段注意</span></a></h2><ul><li><p>django 1.8 增加了存储二进制的字段类型。当存储大容量二进制值，成为系统存储瓶颈时，可将二进制值放到文件中，使用 filefield 字段类型来解决。</p></li><li><p>不要用这个字段存储文件。 原因：</p><ul><li>访问数据库，没有访问文件块</li><li>备份数据库，耗时增加</li><li>去访问文件，需要通过你的django app 。</li></ul></li></ul><h2 id="尽量避免使用通用关联关系" tabindex="-1"><a class="header-anchor" href="#尽量避免使用通用关联关系"><span>尽量避免使用通用关联关系</span></a></h2><ul><li>加快查询速度</li><li>减少数据损坏造成的关联数据的问题</li></ul><h2 id="善于使用meta" tabindex="-1"><a class="header-anchor" href="#善于使用meta"><span>善于使用meta</span></a></h2><h2 id="自定义manager管理器时注意" tabindex="-1"><a class="header-anchor" href="#自定义manager管理器时注意"><span>自定义manager管理器时注意</span></a></h2><ul><li>抽象基类中，子类不能继承父类的 manager</li><li>会造成不能预知的问题</li><li><code>objects = models.Manager()</code> 放在所有自定义管理器的前边。</li></ul><h2 id="理解-fat-models" tabindex="-1"><a class="header-anchor" href="#理解-fat-models"><span>理解“Fat models”</span></a></h2><ul><li><p>model behaviors 利用model的继承（抽象基类）特性实现。将model的部分属性或方法提取到一个Mixins中，通过继承来共用。 参考： http://blog.kevinastone.com/django-model-behaviors.html</p></li><li><p>辅助函数的使用。抽象对模型的重复操作，放到utility 函数中作为模型辅助函数。</p></li></ul>',20))])}const u=t(m,[["render",h]]),f=JSON.parse('{"path":"/pages/3e4c16/","title":"Django 最佳实践-读书笔记 - 第六章 model 最佳实践","lang":"zh-CN","frontmatter":{"title":"Django 最佳实践-读书笔记 - 第六章 model 最佳实践","tags":["Django","Django最佳实践"],"permalink":"/pages/3e4c16/","createTime":"2023/09/08 17:36:02","description":"第六章 model 最佳实践 当app的model过多时，拆分app 当app的model过多时，说明这个app的功能够大，此时就需要我们拆分app了。 模型继承的使用 抽象基类（区别django的抽象基类和python的抽象类） 多表继承（尽量不要使用，效率低下） 代理模式 数据模型的规范化 同数据库设计的规范化，推荐阅读： http://en.wi...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Django 最佳实践-读书笔记 - 第六章 model 最佳实践\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-30T08:57:49.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://pylixm.top/pages/3e4c16/"}],["meta",{"property":"og:site_name","content":"底层逻辑"}],["meta",{"property":"og:title","content":"Django 最佳实践-读书笔记 - 第六章 model 最佳实践"}],["meta",{"property":"og:description","content":"第六章 model 最佳实践 当app的model过多时，拆分app 当app的model过多时，说明这个app的功能够大，此时就需要我们拆分app了。 模型继承的使用 抽象基类（区别django的抽象基类和python的抽象类） 多表继承（尽量不要使用，效率低下） 代理模式 数据模型的规范化 同数据库设计的规范化，推荐阅读： http://en.wi..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-30T08:57:49.000Z"}],["meta",{"property":"article:tag","content":"Django最佳实践"}],["meta",{"property":"article:tag","content":"Django"}],["meta",{"property":"article:modified_time","content":"2025-09-30T08:57:49.000Z"}]]},"readingTime":{"minutes":1.57,"words":472},"git":{"createdTime":1759222669000,"updatedTime":1759222669000,"contributors":[{"name":"pylixm","username":"pylixm","email":"pyli.xm@gmail.com","commits":1,"avatar":"https://avatars.githubusercontent.com/pylixm?v=4","url":"https://github.com/pylixm"}]},"autoDesc":true,"filePathRelative":"01.开发语言/01.Python/03.Best.Practices.for.Django/06.Best.Practices.for.Django.1.8.3rd-Chapter-6.md","headers":[],"categoryList":[{"id":"59843f","sort":1,"name":"开发语言"},{"id":"9d2a49","sort":1,"name":"Python"},{"id":"34f757","sort":3,"name":"Best.Practices.for.Django"}]}');export{u as comp,f as data};
